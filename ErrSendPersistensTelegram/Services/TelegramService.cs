using ErrSendApplication.Common.Configs;
using Microsoft.Extensions.Options;
using System.Text;
using System.Text.Json;
using ErrSendApplication.Interfaces.Client;
using ErrSendApplication.Interfaces.Telegram;

namespace ErrSendPersistensTelegram.Services
{
    public class TelegramService : ITelegramService
    {
        private const string TelegramApiUrl = "https://api.telegram.org/bot";
        private const string SendMessageEndpoint = "/sendMessage";
        private const string HtmlParseMode = "HTML";

        private readonly IHttpClientWr httpClient;
        private readonly TelegramConfig telegramConfig;

        public TelegramService(
            IHttpClientWr httpClient, 
            IOptions<TelegramConfig> telegramConfig)
        {
            this.httpClient = httpClient;
            this.telegramConfig = telegramConfig.Value;
        }

        public async Task SendErrorMessageAsync(string errorMessage, string? additionalInfo = null)
        {
            try
            {
                // –í–∞–ª—ñ–¥–∞—Ü—ñ—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤
                if (string.IsNullOrWhiteSpace(errorMessage))
                {
                    return;
                }

                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó
                if (string.IsNullOrEmpty(telegramConfig.BotToken) || string.IsNullOrEmpty(telegramConfig.ChatId))
                {
                    return;
                }

                var message = FormatErrorMessage(errorMessage, additionalInfo);
                var url = $"{TelegramApiUrl}{telegramConfig.BotToken}{SendMessageEndpoint}";

                var payload = new TelegramSendMessageRequest
                {
                    ChatId = telegramConfig.ChatId,
                    Text = message,
                    ParseMode = HtmlParseMode
                };

                var jsonPayload = JsonSerializer.Serialize(payload);

                var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");
                await httpClient.PostAsync(url, content);
            }
            catch
            {
                // –Ü–≥–Ω–æ—Ä—É—î–º–æ –ø–æ–º–∏–ª–∫–∏
            }
        }

        private string FormatErrorMessage(string errorMessage, string? additionalInfo)
        {
            var sb = new StringBuilder();
            sb.AppendLine("üö® <b>–ü–æ–º–∏–ª–∫–∞ –≤ –¥–æ–¥–∞—Ç–∫—É</b>");
            sb.AppendLine($"‚è∞ <b>–ß–∞—Å:</b> {DateTime.Now:dd.MM.yyyy HH:mm:ss}");
            sb.AppendLine($"‚ùå <b>–ü–æ–º–∏–ª–∫–∞:</b> {System.Net.WebUtility.HtmlEncode(errorMessage)}");

            if (!string.IsNullOrWhiteSpace(additionalInfo))
            {
                // –î–µ–∫–æ–¥—É—î–º–æ, —è–∫—â–æ —Ä–∞–ø—Ç–æ–º –ø—Ä–∏–π—à–æ–≤ URL-encoded —Ç–µ–∫—Å—Ç
                var decodedInfo = System.Net.WebUtility.UrlDecode(additionalInfo);
                sb.AppendLine($"‚ÑπÔ∏è <b>–î–æ–¥–∞—Ç–∫–æ–≤–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è:</b> {System.Net.WebUtility.HtmlEncode(decodedInfo)}");
            }

            return sb.ToString();
        }
    }

    // –¢–∏–ø—ñ–∑–æ–≤–∞–Ω–∏–π –∫–ª–∞—Å –¥–ª—è Telegram API –∑–∞–ø–∏—Ç—É (—Ç—Ä–µ–±–∞ –±—É–¥–µ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –≤ —ñ–Ω—à–∏–π —Ñ–∞–π–ª)
    internal class TelegramSendMessageRequest
    {
        [System.Text.Json.Serialization.JsonPropertyName("chat_id")]
        public string ChatId { get; set; } 
        [System.Text.Json.Serialization.JsonPropertyName("text")]
        public string Text { get; set; } 
        [System.Text.Json.Serialization.JsonPropertyName("parse_mode")]
        public string ParseMode { get; set; } 
    }
} 

